<!DOCTYPE html>

<head>
    <meta name="keywords" content="remark,remarkjs,markdown,slideshow,presentation">
    <meta name="description" content="A simple, in-browser, markdown-driven slideshow tool.">


    <title>Algorismes de Cerca</title>
    <meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="common/print.css" media="print">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, 
      .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .red { color: #fa0000; }
      .green { color: #00fa77; }
      .blue { color: #0000fa; }
      .light { color: #aaaaaa; }
      .bold { font-family: 'Yanone Kaffeesatz'; font-size: 1.5em;
              line-height: 0.9em;}
      .code {font-family: 'Ubuntu Mono';}
      .footnote {
        bottom: 12px;
        left: 20px;
        font-size: 0.75em;
        line-height: 0.4em;
      }

      .summary {
        background:#003366;
        color: #ffffcc;
      }
	  
	  .summary a{
        color: #ffddaa;
	  }

      .exam {
        background: #802222;
        color: #ffffcc;
        text-shadow: 0 0 20px #333;
      }

      .inverse {
        background: #800000;
        color: #ffffcc;
      }

      .inverse h1, 
      .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
        font-size: 0.6em;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        background-color: #eff;
        width: 28%;
        height: 92%;
        float: left;
		font-size: 0.6em;
		font-family: Arial;
      }
	  .left-column strong {
		font-weight:800;
	  }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
		padding-top:0;
		margin-top:0;
        width: 67%;
        float: right;
      }
details {
    border: 1px solid #aaa;
    border-radius: 4px;
    padding: .5em .5em 0;
    margin-bottom: 10px;
}

summary {
    font-weight: normal;
    padding: .5em;
    background-color: #f2f2f2;
    margin-bottom: 10px;
}

details[open] {
    padding: .5em;
}

details[open] summary {
    border-bottom: 1px solid #aaa;
    margin-bottom: .5em;
}

div.warnred {    
    background-color: #fcf2f2;
    border-color: #dFb5b4;
    border-left: 5px solid #dfb5b4;
    padding: 0.5em;
    margin-top: 10px;
    margin-bottom: 10px;
    }

div.warnblue {    
    background-color: #99ccff;
    border-color: #dFb5b4;
    border-left: 5px solid #0066ff;
    padding: 0.5em;
    margin-top: 10px;
    margin-bottom: 10px;
    }

    </style>

<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
</head>

  <body>
  <textarea id="source">


class: center, middle

<center><img src="images/ub.png" width="150"></center>


# **ALGORÍSMICA**
## Algorismes de Cerca


Jordi Vitrià, Mireia Ribera

.blue[jordi.vitria@ub.edu] |  .blue[ribera@ub.edu]

---

## Algorismes de cerca

El concepte de cerca inclou diferents idees:

+ Cerca d’un determinat element en una llista (màx, x=“a”, el que compleix una certa condició, etc.).
+  Cerca d’un determinat element en una llista *ordenada*.
+ Cerca en una estructura de dades complexa, tal com un graf o un arbre.
+ Satisfacció de restriccions.
+ Etc.

Ens centrarem en la **cerca en llistes**.

---

## Algorismes de cerca: cerca lineal
L’algorisme que implementa la cerca d’un element en una llista amb una estratègia de força bruta es diu **cerca seqüencial o lineal**. La complexitat de l’algorisme és `O(n)` en el pitjor cas!
```python
def linsearch(list,ele):
  i=0
  while i < len(list) and list[i] != ele:
    i += 1
  if i < len(list):
      return i
  else:
        return -1
``` 

---
## Algorismes de cerca: cerca lineal (millorat)

Podem fer una petita millora si afegim l’element que busquem al final de la llista:

```python
def linsearch(list,ele):
  list.append(ele)
  i=0
  while list[i] != ele:
    i += 1
  if i < len(list)-1: 
      return i
  else: 
      return -1
``` 

Recordeu de que `list.append(ele)` té una complexitat `O(1)` i per això surt a compte fer-ho!

Si enlloc de ser `O(1)` fos `O(n)` (com per exemple `list.insert(ele)`) ja no valdria la pena.

Notebook a Colab: [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/algorismica2020/algorismica2020.github.io/blob/master/notebookscolab/CercaLineal.ipynb)
---
name:cercbin

## Algorismes de cerca en llistes ordenades

I si la llista està ordenada (un diccionari, els nombres de la loteria, etc.), ho podem fer millor?


<center><img src="images/cerca11.png" width="550" alt="resultats de la loteria i pàgina d'un diccionari"></center>


---

## Algorismes de cerca: cerca binària


La **cerca binària** consisteix en comparar l’element cercat `K` amb l’element central de la llista: si hi ha correspondència ja l’hem trobat, altrament, busquem a la subllista (de la dreta o de l'esquerra) que correspon. 

<center><img src="images/cerca12.png" width="550" alt=""></center>


---
## Cerca binària: exemple amb lletres


<center><img src="images/cerca13.png" width="650" alt="en el vector ordenat de les lletres A a X es busca la lletra J, els diferents passos són comparar-lo amb L, amb F, amb I i finalment amb J"></center>

> Com acaba l’algorisme si `J` no hi és?

---
## Cerca binària: exemple amb nombres

`l` (low) indica el límit inferior de la subllista a buscar, `h` (high) el límit superior, `m` (middle) el punt de comparació,  K el nombre a buscar, en aquest cas **K=70**.

<center><img src="images/cerca14.png" width="650" alt="es busca 70 en una llista de nombres ordenats, es mostren els límits inferiors, superiors i mitjos de la cerca"></center>

A la primera iteració comparem 55 amb 70. Com que 55 és menor seguim la cerca per la dreta.

A la segona iteració comparem 85 amb 70. Com que 85 és més gran seguim la cerca per l'esquerra

A la tercera iteració comparem 74 amb 70. Com que 74 és més gran seguim la cerca per l'esquerra.

A la quarta iteració comparem 70 amb 70. Com que són iguals, acabem.

---
## Cerca binària: complexitat


Per analitzar la seva complexitat calcularem el nombre de vegades que la clau de la cerca, `K`, es compara amb un element de la llista.

En el pitjor dels casos (quan l’element no hi és), tenim aquesta relació de recurrència: `T(n) = T(n/2) + 1`. Ja que només fem una crida recursiva, i a cada crida dividim el problema per la meitat.


Segons el teorema Màster això és `O(log`<sub>2</sub>`n)`: per una llista de 1.000.000 elements són 20 comparacions!

Evidentment és un algorisme recursiu, però és pot implementar fàcilment de forma no recursiva.

---
## Cerca binària: algorisme i complexitat

```python
def binsearch(nums, K):
    low = 0
    high = len(nums)-1
    while low <= high:                     
        mid = (low + high) // 2            
        if nums[mid] > K: high = mid - 1
        elif nums[mid] < K: low = mid + 1
        else: return mid                           
    return -1 
```
Notebook a Colab: [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/algorismica2020/algorismica2020.github.io/blob/master/notebookscolab/CercaBinaria.ipynb)

El cas promig és més difícil d’analitzar, però es pot demostrar que és només una mica millor que el pitjor cas (tot i que del mateix ordre).

> Observació: *Si tenim una llista desordenada de mida n i només hem de buscar un element (o pocs), apliquem una cerca exhaustiva.  Però si hem de fer moltes cerques (de l’ordre de n), val la pena ordenar-la primer i fer cerca binària dels elements després!*

En general considerem que **la complexitat de la cerca binària sobre una llista ordenada és de `O(log`<sub>2</sub> `n)`**.

---

##  Exemple de problema: cerca dels extrems d'una funció.

Algunes cerques no són tan senzilles com buscar un element o el màxim dins una llista acotada.

Per exemple, en la funció següent, com busquem el màxim? quin tipus de cerca hi podem aplicar?

<center><img src="images/fun1.png" width="450" alt="gràfic d'una funcio multimodal" ></center>

---
##  Exemple - Solució amb cerca exhaustiva

Podem aplicar-hi cerca exhaustiva (de complexitat `O(n)`, on `n` és el nombre de `x` de la funció que conisderem):

```python
def func1d(x): # funció multimodal de la que buscarem max
    import math
    y = x * math.sin(10*math.pi*(x))+1.0
    return y

def frange(start, stop, step): 
# definim un range sobre floats per conveniència 
    current = start 
    while current < stop:
        yield current   #yield proveeix un resultat i segueix
        current += step

def linsearchfunc1d():   # la funció de cerca 
    x = -1  #valor inicial d'x
    maxim=func1d(x)  # valor inicial d'y 
    for i in frange(-1.0,2.0,0.01):
        if func1d(i)>maxim: 
            maxim=func1d(i)
            x=i
    print(x, maxim)

```

Notebook a Colab: [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/algorismica2020/algorismica2020.github.io/blob/master/notebookscolab/CercaExhaustiva.ipynb)

---

##  Cerca exhaustiva = intractable

Si el nombre de punts a mostrejar és molt gran tenim un problema!

<center><img src="images/fun2.png" width="250" alt="gràfic 3D d'una funció amb 4 extrems"></center>

En aquest cas si analitzem els punts amb una precisió de `0.01` analitzaríem `300x300` punts. Si necessitéssim una precisió `0.000001` analitzaríem `3000000x3000000` punts. 

No podem fer cerca exhaustiva!
---
##  Exemple - Solució amb cerca aleatòria

Té sentit fer una cerca aleatòria? (= anar generant nombres de forma aleatòria dins del rang de les variables i comparar el valor de la funció).

<center><img src="images/fun4.png" width="450" alt="distribució aleatòria de punts en el domini de la funció anterior"></center>

---
##  Cerca aleatòria - Algorisme i reflexió

L'algorisme de cerca aleatòria quedaria com segueix:

```python
def rsearchfunc1d():
    import random
    x = -1  #valor inicial d'x
    maxim=func1d(x)  # valor inicial d'y 
    for i in range(1000): #provem 1000 valors aleatòriament
      xtemp = (random.random()*3.0)-1.0   # valors entre -1 i 2
      if func1d(xtemp)>maxim: 
          maxim=func1d(xtemp)
          x=xtemp
    return x, maxim    
```

En general, la cerca totalment aleatòria **no** és una bona solució: tenim el cost de la cerca afitat, però depèn molt de l’aleatorietat i té un resultat molt semblant, si no equivalent, a la cerca lineal, per força bruta. 

Notebook a Colab: [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/algorismica2020/algorismica2020.github.io/blob/master/notebookscolab/CercaExhaustiva.ipynb)

---
name:genetic

## Algorismes de cerca: cerca amb algorismes genètics.

Anem a veure un tipus d’algorisme aproximat que ens fa una cerca, amb un cert component aleatori més intel·ligent, de l’espai de solucions: la cerca basada en **algorismes genètics**.


El terme *algorismes genètics* s’utilitza per a referir-se a una família bastant àmplia de models computacionals de càlcul basats en els mecanismes d’evolució biològica.

La idea de selecció natural va ser introduïda per Charles Darwin el 1859 dins del seu llibre *L’Origen de Les Espècies*.

Aquesta idea pot servir d’analogia per a construir mètodes de cerca en problemes d’optimització combinatòria i mètodes d’aprenentatge.


---
## Algorismes genètics: Darwin

Darwin va assentar les bases del principi d'evolució per selecció natural amb les següents idees:

+ Cada individu tendeix a passar els seus trets característics a la seva descendència. Tot i així, la natura produeix individus amb trets diferents. 

+ Els individus més adaptats tendeixen a tenir més descendència, i a la llarga, la població tendeix a ser "millor".

+ Al cap d'un llarg període, l'acumulació de canvis pot produir  espècies totalment noves, adaptades al seu entorn.

--

A més a més, la natura disposa d'una sèrie de mecanismes reguladors externs a aquest procés però igualment interessants: el mecanisme de diversitat, els paràsits, les organitzacions socials, etc.

---
## Algorismes genètics: Darwin i creuament


Els mecanismes biològics que fan possible l’evolució són avui coneguts. 

A la natura, podem veure com la transmissió de la informació genètica (genoma) es fa a través de la reproducció sexual. Aquest procediment permet als descendents ser diferents dels seus antecessors, tot i conservar la majoria de trets. 

El mecanisme sobre el que està basada la reproducció es troba a nivell molecular, i consisteix en l'aparellament de cromosomes (on trobem el genoma), l'intercanvi d'informació, i la posterior partició. És el que anomenem **creuament**. 

La probabilitat de que dos individus es creuin depèn de la seva adaptació al medi.
---
## Algorismes genètics: terminologia


Per inspiració d’aquests mecanismes usarem terminologia de biologia per als nostre problemes:
+ Cromosomes: cadascun dels individus de la població
+ Creuaments i mutacions.
+ Funció d’adaptació.
+ Mecanismes  correctors/moduladors: diversitat.

---
## Algorismes genètics: decisions a prendre

Quan dissenyem un algorisme genètic per resoldre un problema caldrà decidir algunes qüestions:

+ Quina és la funció d'adaptació?
+ Com representarem els individus/solucions?
+ Com seleccionarem els individus per reproduir-se?
+ Com creuarem i mutarem els individus?
+ Quina és la probabilitat de mutació?
+ Necessitem mecanismes moduladors (per exemple, diversitat)?

---
## Algorismes genètics: visió general

El **cicle** normal d'un algorisme genètic consisteix en, a partir d'una població amb individus, en la que cada individu és una possible solució...

+ avaluar l'adaptació de cada individu de la població, segons una funció relacionada amb l’objectiu del problema.

+ seleccionar els individus que es creuaran en base a la seva adaptació

+ crear una nova població mitjançant: 
  + creuaments 
  + mutacions

sempre garantint que el resultat dels creuaments i mutacions són també possibles solucions al problema.

+ iterar sobre la nova població fins assolir una certa fita.

Cada una de les iteracions d'aquest cicle es coneix com  a **generació**. 

---
## Algorismes genètics: visió general - representació 

.left-column[
#### Esquema d'un algorisme genètic

- **decidir com representar la població**
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Normalment es considera que la millor **representació** dels cromosomes possible és la **binària**. 

El creuament, la mutació, i d'altres operacions que es poden utilitzar, són aleshores simples operacions a nivell de bit. 
]
---

## Algorismes genètics: visió general - avaluar l'adaptació

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- **avaluar adaptació**
	- **funció adaptació**
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Avaluar l'adaptació ens permet saber si anem trobant solucions millors o si ens apropem a un valor desitjat.

La **funció d’adaptació** és pròpia de cada problema que volem resoldre.

En el problema  de la funció multimodal, per exemple, la funció d’adaptació és el valor de:

 `f(x): (math.sin(10*math.pi*(x))+1.0)`. 

La màxima adaptació correspon al màxim d’aquesta funció multimodal. 
]


---
## Algorismes genètics: visió general - avaluar l'adaptació al TSP

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- **avaluar adaptació**
	- **funció adaptació**
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
El problema del viatjant de comerç també és un problema candidat a ser resolt amb algorismes genètics.

La funció d’adaptació seria `1/d`, on `d` és la distància recorreguda. D'aquesta manera un valor elevat de la funció d'adaptació equival a una bona solució.

Un cromosoma representaria un circuit que és potencialment solució del problema. 
]

---
## Algorismes genètics: adaptació i selecció (introducció al problema)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- **mètode estàndard**
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Suposem doncs que tenim una població inicial de quatre individus amb una adaptació de `8,6,6` i `5` respectivament, i que definim la probabilitat de selecció en funció del valor d'adaptació, *q<sub>i</sub>* com a 

$$ f_i = \dfrac {q_i}{\sum_j q_j} $$ 


|   individu     | valor adaptació (*q<sub>i</sub>*)  | probabilitat de selecció (*f<sub>i</sub>*) |
|:----------------:|:-----------------:|:--------------------------:|
|  000110010111  |8      |32%              |
|  111010101100  |6        |24%              |
|  001110101001  |6        |24%              |
|  111011011100  |5        |20%              |


]
---
## Algorismes genètics: visió general - adaptació i selecció (ruleta)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- **mètode estàndard**
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Una primera alternativa per la selecció és triar parelles aleatòriament tenint en compte la seva probabilitat de selecció.

És com si fem rodar una ruleta i ens va donant individus; l’individu amb més probabilitat de selecció ocupa més posicions a la ruleta.

Exemple:

<center><img src="images/gen2.png" width="400" alt="4 gens de la població es combinen de 2 a 2 per fer 2 parelles" ></center>
]
---
## Algorismes genètics: visió general - creuament

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- **crear nova generació**
	- **creuament**
	- mutació
]

.right-column[
Un cop obtingudes les parelles anteriors, com les creuem?

La forma més simple de creuament és generar un punt de tall aleatori i intercanviar:


<center><img src="images/gen3.png" width="550" alt="als dos membres de la parella se'ls posa un punt de tall, per exemple en el bit 4, la nova generació es crea combinant els bits 0..3 del pare amb els bits 4...n de la mare i viceversa"></center>
]
---
## Algorismes genètics: visió general - mutació

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- **crear nova generació**
	- creuament
	- **mutació**
]

.right-column[
Per a **mutar-los** canviarem el valor d’un quants bits de la població de forma aleatòria.

La probabilitat de que un bit canviï de valor és `β` i la que probabilitat de no canviar és `(1- β)`, però sempre `β < (1- β)`.
]
---
## Algorismes genètics : visió general - recapitulació

En resum, la **funció d’adaptació** depèn del problema que volem resoldre.

La **representació** òptima, és en la majoria de casos i si no hi ha motius fonamentats per dubtar-ho, la binària. La representació ha de facilitar que el resultat d’aplicar els operadors genètics sigui vàlid.

L’operació de **creuament** crea dos nous individus seleccionant punts de creuament en els cromosomes seleccionats i intercanviant les seves parts.

L’operació de **mutació** consisteix en la selecció aleatòria d’algun dels gens del cromosoma i el canvi del seu valor. La probabilitat de mutació ha de ser petita, altrament l'algorisme esdevindria una cerca aleatòria!

---
## Algorismes genètics a fons: selecció

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
La generació següent es forma a partir d’una selecció entre els elements del conjunt format pels cromosomes progenitors i pels cromosomes descendents, però seguint una **estratègia elitista**: el(s) millor(s) cromosomes passen automàticament. Així assegurem que una bona solució no es perd mai.

La probabilitat de selecció per a la següent generació és una ponderació del valor d’adaptació, i es pot fer de diverses maneres: el mètode estàndard (que ja hem vist), el mètode d’ordenació, el mètode de la diversitat, etc.
]
---

## Algorismes genètics a fons: selecció - mètode estàndard

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- **mètode estàndard**
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Recordem aquest mètode:

|   individu     | valor adaptació (*q<sub>i</sub>*)  | probabilitat de selecció (*f<sub>i</sub>*) |
|:----------------:|:-----------------:|:--------------------------:|
|  000110010111  |8        |32%              |
|  111010101100  |6        |24%              |
|  001110101001  |6        |24%              |
|  111011011100  |5        |20%              |


El mètode estàndard té dos inconvenients: 
+ impedeix que els cromosomes "dolents" passin a les futures generacions i puguin transmetre les poques coses que tinguin bones 
+ com que sovint la funció d’adaptació és qualitativa, l'ordre és correcte però els valors no són precisos.
]
---

## Algorismes genètics a fons: selecció - mètode d'ordenació (introducció)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- **mètode d'ordenació**
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Per insensibilitzar el mètode de selecció respecte al valor d'adaptació del problema, podem ordenar els cromosomes segons aquest valor, i els ponderem segons aquesta regla: 

  + Establim un valor aleatori `p` entre `0` i `1`.
  + Al primer cromosoma li assignem aquesta probabilitat
  + Al segon li assignem la probabilitat `p*(1-p)` 
  + La probabilitat de l'`i`-èssim cromosoma és `p * (1 – la probabilitat que s’hagi triat algun cromosoma anterior)`.
]
---
## Algorismes genètics a fons: selecció - mètode d'ordenació (exemple)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- **mètode d'ordenació**
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Per exemple, suposem que `p=0.667`. Llavors:

 <center><img src="images/gen5.png" width="550" alt="càlcul de la probabilitat segons el mètode d'ordenació"></center>
]
---
## Algorismes genètics a fons: selecció - mètode de la diversitat

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- mètode d'ordenació
	- **mètode de la diversitat**
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
El principi de diversitat ens diu que és quasi tan bo ser diferent com estar adaptat. 

Definim la diversitat d'un grup de cromosomes com:

<center><img src="images/gen6.png" width="550" alt="La distància que usem pot ser des del nombre de bits diferents entre cada cromosoma a una funció definida per l'usuari a partir del coneixement del problema. En el nostre exemple considerarem la distància euclidiana sobre punts el pla. En el cas més general podríem fer servir la distància de Hamming"></center>

on *d<sub>i</sub>* és una mesura de distància entre cromosomes. 
]
---

## Algorismes genètics a fons: selecció - mètode de la diversitat - distància entre dos cromosomes

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- **mètode de la diversitat**
		- **distància de Hamming**
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Per a calcular la distància entre dos cromosomes usem la **distància de  Hamming**.

La **distància de Hamming** entre dues cadenes de la mateixa longitud és el nombre de posicions diferents. Si considerem cadenes de bits, correspon al nombre de bits que s'han de canviar d'una cadena perquè passi a tenir el valor d'una altra cadena.

Exemple: la distància de Hamming entre 011101  i  011011 és de 2 ja que per arribar de la primera cadena a la segona cal canviar 2 bits
]
---

## Algorismes genètics a fons: selecció - mètode de la diversitat - aplicació

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- mètode d'ordenació
	- **mètode de la diversitat**
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Per aplicar el mètode de la diversitat, seguim els següents passos:

1. El millor cromosoma passa automàticament a la següent generació (estratègia elitista).
1. Calculem la diversitat de tots els cromosomes respecte als que ja han passat a la següent generació.
1. Ordenem els cromosomes segons la seva funció d’adaptació.
1. Sumem els nombres que representen l’ordre obtingut per cada cromosoma als passos 2 i 3. I reordenem segons aquest valor.
1. Triem el cromosoma que passa a la següent generació segons el mètode d’ordenació i si queden cromosomes per triar, i tornem al punt 2. 
]
---
## Algorismes genètics a fons: selecció - mètode de la diversitat - exemple

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- mètode d'ordenació
	- **mètode de la diversitat**
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
  <center><img src="images/gen7.png" width="250" alt="cromosomes 0100 0001 q=100; cromosomes 0001 0100 q=44; cromosomes 0011 0001 q=32; cromosomes 0001 0010 q=22,5; cromosomes 0001 0001 q=1; cromosomes 0111 0101 q=0"></center>

El cromosoma millor passa a la següent generació. En el nostre cas és el cromosoma `(0100 0001)`. 

Per tant resten per triar 2 cromosomes entre `(0001 0100)`, `(0011 0001)`, `(0001 0010)`, `(0001 0001)`,  `(0111 0101)`.
]
---
## Algorismes genètics a fons: selecció - mètode de la diversitat - exemple (2n pas)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- mètode d'ordenació
	- **mètode de la diversitat**
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Construirem una taula dels cromosomes indicant la diversitat de cada cromosoma respecte als ja seleccionats:

  <center><img src="images/gen8.png" width="550" alt="s'aplica l'ordenació estandard, la diversitat i ordenació i es calcula la probabilitat per cada cromosoma"></center>
]

---

## Algorismes genètics a fons: selecció - mètode de la diversitat - exemple (3er pas).

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- **selecció**
	- mètode estàndard
	- mètode d'ordenació
	- **mètode de la diversitat**
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
Llavors triem el següent que passa, i resulta que és el cromosoma 
`(0001 0100)`. A partir d'aquest moment repetim el procés anterior, però calculant la diversitat respecte al dos cromosomes que ja han passat:

  <center><img src="images/gen9.png" width="550" alt="en el cas d'empats per a l'ordenació resultat de la suma div+ord desempatem segons el valor d'ordenació pura"></center>
]
---

## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (introducció)


Volem trobar la `x` dins del rang `[-1 .. 2]` que maximitza `f`:

  <center><img src="images/gen10.png" width="350" alt="gràfic d'una funció multimodal"></center>

---

## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (representació i precisió)

.left-column[
#### Esquema d'un algorisme genètic

- **decidir com representar la població**
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
+ Utilitzarem un vector binari com a cromosoma per a representar el valor real de la variable `x`. La longitud del vector dependrà del domini `[-1,2]` i de la precisió.

+ Suposem que volem una precisió de 6 decimals (1.000.000 de valors per cada unitat). 
Per tant, necessitem mostrejar el rang en 3.000.000 posicions, o sigui, 22 bits:
`2.097.152 = 2^21 < 3.000.000 < 2^22 = 4.194.304`.
]
---

## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (representació binària i real)

.left-column[
#### Esquema d'un algorisme genètic

- **decidir com representar la població**
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
La transformació d'una seqüència binària `[b`<sub>21</sub>`,...,b`<sub>0</sub>`]` a un nombre real `x` es fa en dos passos:

+ Primer convertim la seqüència de base 2 a base 10.
+  Després trobem el nombre real corresponent:

  <center><img src="images/gen11.png" width="250" alt="x=-1.0+ x' * 3 / (2^22 -1)"></center>


> on `-1.0` és el límit esquerra de l'interval i `3` la longitud. 
]
---

## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (algorisme, part 1)

L'algorisme té els següents passos:

+ Escollim com a població inicial 50 individus de forma aleatòria:

```python
# Creem la població inicial

def initpop(n,long):
    import random

           # Generem una poblacio de n cromosomes de longitud long. 
    pop = [[0] * long for x in range(n)]
    for i in range(n):
        for j in range(long):
            if random.random()>0.5: pop[i][j] += 1 
    return pop

```

Notebook a Colab: [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/algorismica2020/algorismica2020.github.io/blob/master/notebookscolab/FuncioMultimodal-AlgGenetics.ipynb)
---

## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (algorisme, part 2)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- **avaluar adaptació**
	- **funció adaptació**
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- crear nova generació
	- creuament
	- mutació
]

.right-column[
+ La funció d'daptació serà equivalent a la funció del gràfic `f`:

```python

# Definim la funció d'adaptació 
# d’un cromosoma de len(r) bits.

def fit(r):
    import math
           # Transformem els bits en un valor real 
		   # a l'interval [-1,2]
    sum=0.0
    for i in range(len(r)):
        sum = sum + r[i]*(2**i)
    x = -1.0 + sum * (3.0/(2.0**(len(r))-1.0))
           # Avaluem el cromosoma
    y = x * math.sin(10*math.pi*(x))+1.0
    return y
```
]
---

## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (mutació)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- **crear nova generació**
	- creuament
	- **mutació**
]

.right-column[
Per fer la mutació imposem una probabilitat de mutació `pm = 0.01` per a cada bit.  

Per exemple, 

+ si tenim el cromosoma `v3 = 1110000000111111000101`, que té com a valor f(x3) 2.250650

+ seleccionem el cinquè bit per mutar,

+ obtindrem `v3' = 1110100000111111000101`. 

+  el nou cromosoma representa el valor `x3'=1.721638`, i per tant `f(x3') = 2.343555`

+  `f(x3')` s'ha incrementat respecte `f(x3)`.
]
---
## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (algorisme, part 3)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- **crear nova generació**
	- creuament
	- **mutació**
]

.right-column[
```python
# Definim la mutació amb probabilitat mutprob

def mutacio(r,mutprob):
   import random
    for i in range(len(r)):
        if random.random() < mutprob: 
            if r[i]==0: r[i]=1
            else: r[i]=0
    return r

```
]
---
## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (algorisme, part 4)

.left-column[
#### Esquema d'un algorisme genètic

- decidir com representar la població
- avaluar adaptació
	- funció adaptació
- selecció
	- mètode estàndard
	- mètode d'ordenació
	- mètode de la diversitat
		- distància de Hamming
- **crear nova generació**
	- **creuament**
	- mutació
]

.right-column[
Per al creuament d’una parella de cromosomes escollirem aleatòriament un punt de tall i intercanviarem informació per crear els dos descendents. 

```python
# Definim el creuament

def creuament(r1,r2):
    import random
    i=random.randint(1,len(r1)-2)
    return r1[:i]+r2[i:],r1[i:]+r2[:i]

```
]
---

## Aplicació dels algorismes genètics a l'optimització d'una funció multimodal (algorisme, part 5)

Si iterem l'algorisme 150 generacions trobem que el millor cromosoma és 
`vmax = (1111001101000100000101)`, que correspon al valor `xmax = 1.850773`. 

L'evolució de l'algorisme es pot avaluar a partir del millor valor de la funció aconseguit en cada generació:

```python
1     1.441942
6     2.150003
8     2.250283
9     2.250284
10    2.250363
12    2.328077
39    2.344251
51    2.733893
99    2.849246
137   2.850217
145   2.850227
```
---
## Algorismes genètics: Complexitat

Quin és el factor que més pesa en el càlcul de la complexitat computacional de l’algorisme? 

--
**El nombre d'avaluacions!**


--
Els operadors genètics tenen un cost  computacional menyspreable i  per tant la complexitat de l’algorisme és el nombre d’avaluacions per la complexitat de l’avaluació.

A l'exemple de la funció multimodal hem fet `50x150=7.500` avaluacions! ja que teniem 50 individus i hem iterat durant 150 generacions.







</textarea>
  <script src="common/remark-latest.min.js"></script>
  <script>
    var hljs = remark.highlighter.engine;
  </script>
  <script src="common/remark.language.js"></script>
  <script>
    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLanguage: 'remark',
      highlightLines: true
    });
    var slideshow = remark.create({
                // Set the slideshow display ratio
                // Default: '4:3'
                // Alternatives: '16:9', ...
                ratio: '4:3',

                // Navigation options
                navigation: {
                  // Enable or disable navigating using scroll
                  // Default: true
                  // Alternatives: false
                  scroll: true,

                  // Enable or disable navigation using touch
                  // Default: true
                  // Alternatives: false
                  touch: true,

                  // Enable or disable navigation using click
                  // Default: false
                  // Alternatives: true
                  click: false
                },

                // Customize slide number label, either using a format string..
                slideNumberFormat: 'Slide %current% of %total%',
                // .. or by using a format function
                slideNumberFormat: function (current, total) {
                  return 'Slide ' + current + ' of ' + total;
                },

                // Enable or disable counting of incremental slides in the slide counting
                countIncrementalSlides: true
              }); 

  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>

  <script type="text/javascript">
// Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });

      MathJax.Hub.Configured();
  </script>
</body>

</html>